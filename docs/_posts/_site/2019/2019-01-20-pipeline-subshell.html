<p>最近写一个shell脚本，遇到了一个奇怪的现象，经过一番查询发现之前没有注意过的陷阱：Shell（至少是Bash）会将管道运算符的前后命令放到子shell里执行。这将导致：看似在一个脚本的变量，出现改动后没效果的现象。下面是问题背景，关于此问题可以直接跳到“问题”一节查看。</p>
<h1 id="背景">背景</h1>
<p>用nmon监控机器的CPU等数据，若要转换成可视化图表，可以使用IBM提供的<a href="https://www.ibm.com/developerworks/community/wikis/home?lang=en#!/wiki/Power+Systems/page/nmon_analyser">nmon Excel宏</a>来生成。但要借助Excel生成，不方便批量处理，太麻烦了。若是能用命令行生成网页，直接在服务器上看就好了。</p>

<p>正好nmon for linux本身就提供了生成网页版的工具<a href="http://nmon.sourceforge.net/pmwiki.php?n=Site.Nmonchart"><code class="highlighter-rouge">nmonchart</code></a>，<code class="highlighter-rouge">nmonchart</code>的原理是通过shell生成HTML，然后调用google的图表库渲染。</p>

<p>我将70台服务器上的nmon输出文件下载到某台机器上，然后准备用将其转换成HTML文件，并通过通过<code class="highlighter-rouge">Python</code>的<code class="highlighter-rouge">SimpleHTTPServer</code>模块启动一个简单的HTTP服务器，大家就可以方便的通过浏览器查看每台机器的nmon的可视化结果了。</p>

<p>任务本身很简单，只需循环将文件名传给<code class="highlighter-rouge">nmonchart</code>即可，假如<code class="highlighter-rouge">nmon</code>的输出文件都已下载到<code class="highlighter-rouge">/home/maoshuai/nmon_files</code>下面，则做如下处理：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd home/maoshuai/nmon_files
ls -1 *.nmon | while read fileName;do
  nmonchart $fileName ${fileName}.html
</code></pre></div></div>

<p>然后发现速度太慢，每个<code class="highlighter-rouge">nmon</code>文件要30多秒才能转换完毕，算下来要30多分钟才能处理完毕。top查看nmonchart调用的sed进程已经100%的CPU，但只能运行在一个CPU上，这是因为shell只能跑在一个CPU上。而当前机器有30个cpu都是空闲，显然是浪费。</p>

<p>接下来需要优化，即将任务分配到30个cpu上并行执行。思路是，先将nmon文件按照CPU的个数拆分为多个组，比如有60个nmon文件，则每个组分2个nmon文件。然后根据CPU的个数起多个后台任务。具体如下：</p>

<p>首先编写一个函数，接受以空格为分隔的文件名，用于处理多个nmon的转换</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gen(){
    cd home/maoshuai/nmon_files
    for fileName in $1;do
      nmonchart $fileName ${fileName}.html
}
</code></pre></div></div>

<p>然后将所有nmon文件，根据CPU个数拆分为多个组：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># get total cpu number
cpuNum=$(cat /proc/cpuinfo | grep "physical id" | wc -l)

cpuIndex=0
cd home/maoshuai/nmon_files

# divide files into serveral groups by cpuIndex
ls -1 *.nmon | while read fileName;do
    # append new file by space
    nmon_files_arr[$cupIndex]="${nmon_files_arr[$cpuIndex]} $fileName" 
    # update cpuIndex
    let "cpuIndex=(cpuIndex+1)%$cpuNum"

</code></pre></div></div>

<p>最后，按组执行多个后台任务</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># launch multi backgroud tasks

for i in $(seq 0 ${#nmon_files_arr[*]};do
    groupFiles=${nmon_files_arr[i]}
    # backgroud running
    gen "$groupFiles" &amp;
done
# wait all backgroup task
wait
echo "All done!"
</code></pre></div></div>

<p>一切看起来没问题，但第二部的拆分出了问题，我发现最后nmon_files_arr是空，但在循环内echo出来并不是空。</p>

<h1 id="问题">问题</h1>
<p>将上面的问题做个简化。发现确实是这样，比如下面的代码，将/tmp下的文件编号输出，并最后输出总文件数：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i=0
ls -1 /tmp | while read fileName;do
    let "i=i+1";
    echo "$i $fileName";
done
echo "total file num: $i"
</code></pre></div></div>

<p>但得到的结果如下：
<img src="https://cdn.imshuai.com/images/2019/01/Screen-Shot-2019-01-20-at-11.30.39.jpg" alt="Screen-Shot-2019-01-20-at-11.30.39" /></p>

<p>虽然while循环内变量i在递增，但while之外变量i还是保持为0，似乎while循环内的改变不起作用。</p>

<p>进一步简化：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>name="shuai"
name="jack" | echo $name
echo $name
</code></pre></div></div>
<p>发现竟然两次输出的内容为还是shuai。这下看来蹊跷了，经过一番Google，<a href="http://www.linuxprogrammingblog.com/pipe-in-bash-can-be-a-trap">确实有人也遇到过</a>，根本原因是：<strong>管道运算符会将命令放到子shell中执行，子shell自然无法修改父shell的变量</strong>，而这一点在Bash的man文档里有一句话轻描淡写的一带而过：</p>
<blockquote>
  <p>Each command in a pipeline is executed as a separate process (i.e., in a subshell).</p>
</blockquote>

<p>注意是<code class="highlighter-rouge">each</code>这个关键字，意思是管道符左右都是在subshell里执行。这就是为什么最后一个例子两次都输出shuai的原因。</p>

<h1 id="解决办法">解决办法</h1>
<p>针对上面的问题，可以通过消除管道的办法来解决，比如使用for代替：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i=0
for fileName in $(ls -1 /tmp);do
    let "i=i+1";
    echo "$i $fileName";
done
echo "total file num: $i"
</code></pre></div></div>

<p>或者干脆把后面的语句，整体通过大括号放到一个子shell里：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ls -1 /tmp |{
i=0
while read fileName;do
    let "i=i+1";
    echo "$i $fileName";
done
echo "total file num: $i"
}
</code></pre></div></div>

<p>或者使用Here string</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i=0
while read fileName;do
    let "i=i+1";
    echo "$i $fileName";
done&lt;&lt;&lt;$(ls -1 /tmp)
echo "total file num: $i"
</code></pre></div></div>
<h1 id="总结">总结</h1>
<ol>
  <li>Shell中（至少是bash），管道符左右的命令都是在子shell中执行的。</li>
  <li>由于子shell无法修改父shell的变量，因此管道符两边的变量互相不影响，并且无法修改父shell的变量。</li>
  <li>可以通过for或here string等方法规避这个问题，解决变量不通的问题。</li>
</ol>

