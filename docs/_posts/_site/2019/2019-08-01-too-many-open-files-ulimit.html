<p><code class="highlighter-rouge">Too many open files</code>是Java常见的异常，通常是由于系统配置或程序打开过多文件导致。这个问题常常又与<code class="highlighter-rouge">ulimit</code>的使用相关。关于<code class="highlighter-rouge">ulimit</code>的用法有不少坑，本文将遇到的坑予以梳理。</p>

<h1 id="too-many-open-files异常">Too many open files异常</h1>
<p>下面是Java在系统超过最大打开文件数时的异常堆栈：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Exception</span> <span class="n">in</span> <span class="n">thread</span> <span class="s">"main"</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">IOException</span><span class="o">:</span> <span class="n">Too</span> <span class="n">many</span> <span class="n">open</span> <span class="n">files</span>
	<span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">UnixFileSystem</span><span class="o">.</span><span class="na">createFileExclusively</span><span class="o">(</span><span class="n">Native</span> <span class="n">Method</span><span class="o">)</span>
	<span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">File</span><span class="o">.</span><span class="na">createTempFile</span><span class="o">(</span><span class="n">File</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">2024</span><span class="o">)</span>
	<span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">File</span><span class="o">.</span><span class="na">createTempFile</span><span class="o">(</span><span class="n">File</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">2070</span><span class="o">)</span>
	<span class="n">at</span> <span class="n">com</span><span class="o">.</span><span class="na">imshuai</span><span class="o">.</span><span class="na">wiki</span><span class="o">.</span><span class="na">ulimit</span><span class="o">.</span><span class="na">App</span><span class="o">.</span><span class="na">main</span><span class="o">(</span><span class="n">App</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">16</span><span class="o">)</span>
</code></pre></div></div>
<p>如果不是程序问题（程序问题，需要看为什么打开很多文件，比如通过lsof），一般要通过ulimit调整打开文件数限制解决，但ulimit本身也有不少坑，下面做一下总结。</p>

<h1 id="什么是ulimit">什么是ulimit</h1>
<p>直接参考ulimit的帮助文档（注意：不是man ulimit，而是help ulimit，ulimit是内置命令，前者提供的是C语言的ulimit帮助）：</p>
<blockquote>
  <p>Modify shell resource limits.</p>

  <p>Provides control over the resources available to the <strong>shell and processes it creates</strong>, on systems that allow such control.</p>
</blockquote>

<p>可以看出，<strong>ulimit提供了对shell（或shell创建的进程）可用资源的管理</strong>。除了打开文件数之外，可管理的资源有：
最大写入文件大小、最大堆栈大小、core dump文件大小、cpu时间限制、最大虚拟内存大小等等，help ulimit会列出每个option限制的资源。或者查看<code class="highlighter-rouge">ulimit -a</code>也可以看出：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>maoshuai@ms:~/ulimit_test$ ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) 100
pending signals                 (-i) 15520
max locked memory       (kbytes, -l) 16384
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 15520
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
</code></pre></div></div>

<h1 id="理解ulimit">理解ulimit</h1>
<p>在使用ulimit之前，有几个容易迷糊的点：</p>
<h2 id="ulimit的管理的维度">ulimit的管理的维度</h2>
<p>理解ulimit，第一个疑问是限制的维度是什么。比如nofile设置为1024，是指<strong>当前用户</strong>总共只能打开1024个文件，还是<strong>单个shell会话进程</strong>只能打开1024个文件？**  实际上help ulimit里已经说清楚了：process，但我们可通过下面的方法程序验证：</p>

<p>下面通过一段java程序，打开800个文件：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Ulimit</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span> <span class="n">String</span><span class="o">[]</span> <span class="n">args</span> <span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">InterruptedException</span>
    <span class="o">{</span>
    	<span class="n">List</span><span class="o">&lt;</span><span class="n">FileInputStream</span><span class="o">&gt;</span> <span class="n">fileList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">FileInputStream</span><span class="o">&gt;();</span>
    	<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">800</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    		<span class="n">File</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">File</span><span class="o">.</span><span class="na">createTempFile</span><span class="o">(</span><span class="s">"ulimit-test"</span><span class="o">,</span> <span class="s">".txt"</span><span class="o">);</span>
    		<span class="n">fileList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="n">temp</span><span class="o">));</span>
    		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"file_seq="</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">temp</span><span class="o">.</span><span class="na">getAbsolutePath</span><span class="o">());</span>  
    	<span class="o">}</span>
    	<span class="c1">// keep it running, so we can inspect it.</span>
    	<span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>我们将nofile设置为1024</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ulimit</span> <span class="nt">-n</span> 1024
</code></pre></div></div>
<p>然后我们运行两个进程实例：</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nohup java Ulimit <span class="o">&gt;</span>a.log &amp;
nohup java Ulimit <span class="o">&gt;</span>b.log &amp;
</code></pre></div></div>
<p>查看日志a.log和b.log，都创建了800个文件，没有报异常。</p>

<p>如果将ulimit 设置为700，重新测试，发现java程序在创建688个文件时就报了<code class="highlighter-rouge">Too many open files</code>异常(之所以不是700整，是因为java本身也会打开一些文件)，</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">file_seq</span><span class="o">=</span><span class="mi">688</span> <span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">ulimit</span><span class="o">-</span><span class="n">test7270662509459661456</span><span class="o">.</span><span class="na">txt</span>
<span class="n">Exception</span> <span class="n">in</span> <span class="n">thread</span> <span class="s">"main"</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">IOException</span><span class="o">:</span> <span class="n">Too</span> <span class="n">many</span> <span class="n">open</span> <span class="n">files</span>
        <span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">UnixFileSystem</span><span class="o">.</span><span class="na">createFileExclusively</span><span class="o">(</span><span class="n">Native</span> <span class="n">Method</span><span class="o">)</span>
        <span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">File</span><span class="o">.</span><span class="na">createTempFile</span><span class="o">(</span><span class="n">File</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">2024</span><span class="o">)</span>
        <span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">File</span><span class="o">.</span><span class="na">createTempFile</span><span class="o">(</span><span class="n">File</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">2070</span><span class="o">)</span>
        <span class="n">at</span> <span class="n">Ulimit</span><span class="o">.</span><span class="na">main</span><span class="o">(</span><span class="n">Ulimit</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">12</span><span class="o">)</span>
</code></pre></div></div>
<p>虽然ulimit的u是user的意思，但事实证明，<strong>ulimit控制的维度是shell会话或shell创建的进程（至少对于nofile来说）。即：当前用户打开的文件数，是可以远远超过nofile的值。</strong></p>

<p>所以，通过<code class="highlighter-rouge">lsof | wc -l</code> 查看系统打开文件数，来判断是否打开文件数是否超了，是不正确的。另外，<code class="highlighter-rouge">lsof | wc -l</code> 是也并不反映系统打开的文件数！（后续周刊补充）</p>

<h2 id="soft和hard的区分">soft和hard的区分</h2>
<p>理解ulimit第二个重要方面是soft和hard的区分，ulimit对资源的限制区分为soft和hard两类，即同一个资源（如nofile）存在soft和hard两个值。</p>

<p>在命令上，ulimit通过-S和-H来区分soft和hard。如果没有指定-S或-H，在显示值时指的是soft，而在设置的时候指的是<strong>同时设置soft和hard值</strong>。</p>

<p>但soft和hard的区别是什么是什么呢？下面这段解释较为准确（来自man 2 getrlimit ）</p>

<blockquote>
  <p>The soft limit is the value that the kernel enforces for the corresponding resource.  The hard limit acts as a  <strong>ceiling  for  the soft  limit</strong>:  an unprivileged process may set only its soft limit to a value in the range from 0 up to the hard limit, and** (irre‐versibly) **lower its hard limit.  A privileged process (under Linux: one with the CAP_SYS_RESOURCE capability) may make  arbitrary changes to either limit value.</p>
</blockquote>

<p>归纳soft和hard的区别：</p>
<ol>
  <li>无论何时，soft总是小于等于hard</li>
  <li>无论是超过了soft还是hard，操作都会被拒绝。结合第一点，这句话等价于：超过了soft限制，操作会被拒绝。</li>
  <li>一个process可以修改当前process的soft或hard。但修改需满足规则：
    <ul>
      <li>修改后soft不能超过hard。也就是说soft增大时，不能超过hard；hard降低到比当前soft还小，那么soft也会随之降低。</li>
      <li>非root或root进程都可以将soft可以在[0-hard]的范围内任意增加或降低。</li>
      <li>非root进程可以降低hard，但不能增加hard。即nofile原来是1000，修改为了900，在修改为1000是不可能的。（这是一个单向的，有去无回的操作）</li>
      <li>root进程可以任意修改hard值。</li>
    </ul>
  </li>
</ol>

<p>soft和hard在控制上其实并没有区别，都会限制资源的使用，但soft可以<strong>被进程在使用前自己修改</strong>。</p>

<h2 id="ulimit的修改与生效">ulimit的修改与生效</h2>
<p>知道ulimit很好，但更重要的是怎么修改，这是工作中常见的任务。</p>

<p>关于ulimit的生效，抓住几点即可：</p>
<ol>
  <li>ulimit的值总是继承父进程的设置。</li>
  <li>ulimit命令可修改当前shell进程的设置。这也说明，<strong>为了保证下次生效，修改的地方要具有持久性</strong>（至少相当于目标进程而言），比如.bashrc，或进程的启动脚本）</li>
  <li>从第2点也可以推出，运行中的进程，不受ulimit的修改影响。</li>
  <li>增加hard值，只能通过root完成</li>
</ol>

<p>下面给出两个案例：</p>

<h3 id="案例1某非root进程要求2048的nofile经查看当前soft为1024hard为4096">案例1：某非root进程要求2048的nofile，经查看当前soft为1024，hard为4096</h3>
<p>可以直接在该进程启动脚本中，增加ulimit -nS 2048即可</p>

<h3 id="案例2某非root进程要求10240的nofile经查看当前soft为1024hard为4096">案例2：某非root进程要求10240的nofile，经查看当前soft为1024，hard为4096</h3>
<p>显然，非root用户没法突破。只能通过root修改，一般修改<code class="highlighter-rouge">/etc/security/limits.conf</code>文件，修改方法在该配置文件中的注释中也有说明，格式是：</p>

<p>一条记录包含4️列，分别是范围domain（即生效的范围，可以是用户名、group名或*代表所有非root用户）；t类型type：即soft、hard，或者-代表同时设置soft和hard；项目item，即ulimit中的资源控制项目，名字枚举可以参考文件中的注释；最后就是value。比如将所有非root用户的nofile设置为100000</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">*</span>  hard nofile 10000
<span class="k">*</span>  soft nofile 10000
</code></pre></div></div>

<h2 id="运行中进程的limits的查看">运行中进程的limits的查看</h2>
<p>ulimit修改之后，可以直接通过ulimit命令查看。<strong>对于已运行的进程，还有一种更准确的查看方法</strong>（比如修改ulimit前就启动的进程，如何知道其ulimit值就需要这种方法）：查看进程目录下的limits文件。比如，/proc/4660/limits文件就记录了4660号进程的所有limits值：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>maoshuai@ms:~/ulimit_test<span class="nv">$ </span><span class="nb">cat</span> /proc/4660/limits 
Limit                     Soft Limit           Hard Limit           Units     
Max cpu <span class="nb">time              </span>unlimited            unlimited            seconds   
Max file size             unlimited            unlimited            bytes     
Max data size             unlimited            unlimited            bytes     
Max stack size            8388608              unlimited            bytes     
Max core file size        0                    unlimited            bytes     
Max resident <span class="nb">set          </span>unlimited            unlimited            bytes     
Max processes             15520                15520                processes 
Max open files            2000                 2000                 files     
Max locked memory         16777216             16777216             bytes     
Max address space         unlimited            unlimited            bytes     
Max file locks            unlimited            unlimited            locks     
Max pending signals       15520                15520                signals   
Max msgqueue size         819200               819200               bytes     
Max nice priority         0                    0                    
Max realtime priority     0                    0                    
Max realtime timeout      unlimited            unlimited            us 
</code></pre></div></div>

<h2 id="ulimit不加参数">ulimit不加参数</h2>
<p>曾经有小白直接用<code class="highlighter-rouge">ulimit</code>查看，看到打印出<code class="highlighter-rouge">unlimited</code>，就认为打开文件不受限制。显然这是不对的，<code class="highlighter-rouge">help ulimit</code>中明确指出：</p>
<blockquote>
  <p>If  no option is given, then -f is assumed.</p>
</blockquote>

<p>所以，ulimit不加参数，相当于<code class="highlighter-rouge">ulimit -f -S</code>（没有指定-S或-H就相当于-S），实际上是指可写入的文件最大size。</p>

<h1 id="其他">其他</h1>

<h2 id="如何查看系统打开文件数">如何查看系统打开文件数</h2>
<p>losf命令虽然作用是”list open files”，但用<code class="highlighter-rouge">lsof | wc -l</code>统计打开文件数上非常不准确。主要原因是：</p>

<ul>
  <li>某些情况下，一行可能显示的是线程，而不是进程，对于多线程的情况，就会误以为一个文件被重复打开了很多次</li>
  <li>子进程会共享file handler
如果用<code class="highlighter-rouge">lsof</code>统计，必须使用精巧的过滤条件。更简单和准确的方法是，通过/proc目录查看。获取系统打开文件说，直接查看/proc/sys/file-nr，其中第一个数字就是打开的file数（file-nr说明参考：<a href="https://www.kernel.org/doc/Documentation/sysctl/fs.txt">https://www.kernel.org/doc/Documentation/sysctl/fs.txt</a>）。要查看一个进程的打开文件数，直接查看目录/proc/$pid/fd里的文件数即可：</li>
</ul>

<h2 id="java-自动将nofile的soft提升为hard上限">Java 自动将nofile的soft提升为hard上限</h2>
<p>在研究的过程中，<strong>我发现java程序似乎不受nofile的soft值影响</strong>。查看进程的limits文件（/proc/$pid/limits），才发现nofile的soft被提升为和hard一样。经过全网搜索查询，<strong>发现JDK的实现中，会直接将nofile的soft先改成了和hard一样的值</strong>，可参考：<a href="https://stackoverflow.com/questions/30487284/how-and-when-and-where-jvm-change-the-max-open-files-value-of-linux">How and when and where jvm change the max open files value of Linux?
</a></p>

<h2 id="ubuntu中eclipse中启动的java和命令行启动的javanofile不一样">Ubuntu中eclipse中启动的java和命令行启动的java，nofile不一样</h2>
<p>通过pstree，发现eclipse的java是通过gnome-shell启动的，而命令行是通过gnome-terminal启动的。其中gnome-terminal又是通过systemd –user启动的，而systemd –user似乎不读取/etc/security/limits.conf的值。这个坑的说明有机会再填吧。</p>

<h2 id="file-max控制内核总共可以打开的文件数">file-max控制内核总共可以打开的文件数</h2>
<p>除了ulimit控制外，<code class="highlighter-rouge">/proc/sys/fs/file-max</code>这个文件控制了系统内核可以打开的全部文件总数。所以，即便是ulimit里nofile设置为ulimited，也还是受限的。</p>

<h2 id="ulimit常用选项">ulimit常用选项</h2>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ulimit</span> <span class="nt">-a</span> <span class="c"># 查看所有soft值</span>
<span class="nb">ulimit</span> <span class="nt">-Ha</span> <span class="c"># 查看所有hard值</span>
<span class="nb">ulimit</span> <span class="nt">-Hn</span> <span class="c"># 查看nofile的hard值</span>
<span class="nb">ulimit</span> <span class="nt">-Sn</span> 1000 <span class="c"># 将nofile的soft值设置为1000</span>
<span class="nb">ulimit</span> <span class="nt">-n</span> 1000 <span class="c"># 同时将nofiles的hard和soft值设置为1000</span>
</code></pre></div></div>

<h1 id="参考">参考</h1>
<ul>
  <li><a href="https://community.pivotal.io/s/article/Session-failures-with-Too-many-open-files">Session failures with error “Too many open files”</a></li>
  <li><a href="https://ss64.com/bash/ulimit.html">ulimit man page</a></li>
  <li><a href="https://unix.stackexchange.com/questions/36841/why-is-number-of-open-files-limited-in-linux"><code class="highlighter-rouge">lsof | wc -l</code> sums up a lot of duplicated entries</a></li>
  <li><a href="https://stackoverflow.com/questions/30487284/how-and-when-and-where-jvm-change-the-max-open-files-value-of-linux">How and when and where jvm change the max open files value of Linux?</a></li>
  <li><a href="https://unix.stackexchange.com/questions/176967/why-file-nr-and-lsof-count-on-open-files-differs">Why file-nr and lsof count on open files differs? </a></li>
</ul>

<blockquote>
  <p>本文转自我的知乎专栏<a href="https://zhuanlan.zhihu.com/java-linux">《Java与Linux学习周刊》</a>的<a href="https://zhuanlan.zhihu.com/p/75897823">《第3期：Too many open files以及ulimit的探讨》</a>。
<!--stackedit_data:
eyJoaXN0b3J5IjpbNTYwNDU3MDA4LDM2NDc5NDU2Ml19
--></p>
</blockquote>
